modulo(Prof):- 0 is Prof mod 2.
alphabeta_search([J,Mvt,Res,NumJette,NumGarde],Prof,Seuil,Min,Max,Reserve,March,Trader,Bourse,Valeur):-
	Prof >= Seuil, modulo(Prof),!,
	maximise(J,Res,NumJette,Valeur).
	
alphabeta_search([J,Mvt,Res,NumJette,NumGarde],Prof,Seuil,Min,Max,Reserve,March,Trader,Bourse,Valeur):-
	Prof >= Seuil,\+(modulo(Prof)),!,
	minimise(J,March,Reserve,NumJette,Valeur).
	
alphabeta_search([J,Mvt,Res,NumJette,NumGarde],Prof,Seuil,Min,Max,Reserve,March,Trader,Bourse,,Valeur):-
	length(March,L)
	coups_possibles(0,L,March,Trader,J,Coups),
	find_best2(Coups,Prof,Seuil,Min,Max,Reserve,March,Trader,Bourse,Valeur).

find_best2([],Prof,_,Min,_,_,_,_,_,Min):-
	modulo(Prof).

find_best2([],Prof,_,_,Max,_,_,_,_,Max):-
	\+(modulo(Prof)).
	
find_best2(_,Prof,_,Min,Max,_,_,_,_,Valeur):-
	Min >= Max,!,
	find_best2([],Prof,_,Min,Max,_,_,_,_,Valeur).
	
find_best2([[J,Mvt,Res,NumJette,NumGarde]|Succs],Prof,Seuil,Min,Max,Reserve,March,Trader,Bourse,Valeur):-
	New_Prof is Prof+1,
	alphabeta_search([J,Mvt,Res,NumJette,NumGarde],New_Prof,Seuil,Min,Max,Reserve,March,Trader,Bourse,This_Valeur),
	jouer_coup(J,Mvt,Reserve,March,Trader,B,Res,NumJette,NumGarde,NouvR,NouvM,NouvT,NouvB),
	compare2(Prof,This_Valeur,Min,New_Min,Max,New_Max),
	find_best2(Succs,Prof,Seuil,New_Min,New_Max,NouvR,NouvM,NouvT,NouvB,Valeur).

compare2(Prof,This_Valeur,Min,This_Valeur,Max,Max):-
	modulo(Prof), This_Valeur > Min, !.
	
compare2(Prof,This_Valeur,Min,Min,Max,This_Valeur):-
	\+(modulo(Prof)), This_Valeur < Max, !.
	
compare2(_,_,Min,Min,Max,Max).


/*initialise les ressources nécessaires à l'IA avant de lancer la recherche du meilleur coup*/
/*Détermine les coups possibles à partir de la position courante du trader*/
coups_possibles(3,_,_,_,_,[]):-!.
coups_possibles(Mvt,Taille,M,T,J,[[J,NewMvt,A,D,G],[J,NewMvt,B,G,D]|Suite]):- Mvt < 3, NewMvt is Mvt+1,
								nouv_pos_trader(M,NewMvt,T,NM), abord(NM,G,D,Taille),
								pile(M,G,PG), pile(M,D,PD), top_pile(A,PG), top_pile(B,PD),
								coups_possibles(NewMvt,Taille,M,T,J,Suite).
								
/*Calcule le nombre d'occurence de X dans une liste*/					
nbOccur([],_,0):-!.
nbOccur([X|T],X,Y):- nbOccur(T,X,Z), Y is 1+Z,!.
nbOccur([_|T],X,Z):-nbOccur(T,X,Z).

/*calcule la valeur d'un coup en cherchant à obtenir la valeur la plus grande possible*/
maximise(J,Res,NumJette,M,B,R,Valeur):-recup_val(Res,B,V), val_perdue(J,M,R,NumJette,VP), Valeur is V - VP.

/*Calcule la valeur d'un coup en cherchant à obtenir la valeur la plus petite possible*/
minimise(1,M,R,NumJette,Valeur):-val_perdue(2,M,R,NumJette,Valeur), Valeur is VPerdue*(-1).							
minimise(2,M,R,NumJette,Valeur):-val_perdue(1,M,R,NumJette,VPerdue), Valeur is VPerdue*(-1).
							
val_perdue(J,M,R,NumJette,VPerdue):- pile(R,J,ResJ), pile(M,NumJette,[T|_]),
								    nbOccur(ResJ,T,VPerdue).
	